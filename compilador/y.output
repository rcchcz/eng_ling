Terminals unused in grammar

    TYPE
    LEN_STRING
    COMMENT
    FLOAT_VALUE
    INT_VALUE
    STRING_VALUE
    TRUE_VALUE
    FALSE_VALUE
    COMMA
    DEF
    ARRAY
    STRUCT
    TUPLE
    FOR
    ITERATOR
    ELIF
    BREAK
    RETURN
    BRACES_INITIATOR
    BRACES_TERMINATOR
    BRACKETS_INITIATOR
    BRACKETS_TERMINATOR
    PARENTHESES_INITIATOR
    PARENTHESES_TERMINATOR
    IN
    OUT
    OPEN
    CLOSE
    EQUAL
    NOT_EQUAL
    LEQ
    GEQ
    GREATER_THAN
    NOT
    AND
    OR
    PLUS_OPERATOR
    MINUS_OPERATOR
    MULTI_OPERATOR
    DIVISION_OPERATOR
    MOD_OPERATOR
    POWER_OPERATOR
    CONCAT
    COPY_STRING


State 20 conflicts: 1 shift/reduce


Grammar

    0 $accept: prog $end

    1 prog: stmlist

    2 stm: ID ASSIGN ID
    3    | WHILE ID DO stm
    4    | BLOCK_BEGIN stmlist BLOCK_END
    5    | IF ID THEN stm
    6    | IF ID THEN stm ELSE stm

    7 stmlist: stm
    8        | stmlist SEMICOLON stm


Terminals, with rules where they appear

    $end (0) 0
    error (256)
    ID <sValue> (258) 2 3 5 6
    TYPE <sValue> (259)
    LEN_STRING <sValue> (260)
    ASSIGN (261) 2
    COMMENT (262)
    FLOAT_VALUE (263)
    INT_VALUE (264)
    STRING_VALUE (265)
    TRUE_VALUE (266)
    FALSE_VALUE (267)
    COMMA (268)
    SEMICOLON (269) 8
    BLOCK_BEGIN (270) 4
    BLOCK_END (271) 4
    DEF (272)
    ARRAY (273)
    STRUCT (274)
    TUPLE (275)
    WHILE (276) 3
    FOR (277)
    ITERATOR (278)
    IF (279) 5 6
    ELSE (280) 6
    ELIF (281)
    THEN (282) 5 6
    BREAK (283)
    RETURN (284)
    DO (285) 3
    BRACES_INITIATOR (286)
    BRACES_TERMINATOR (287)
    BRACKETS_INITIATOR (288)
    BRACKETS_TERMINATOR (289)
    PARENTHESES_INITIATOR (290)
    PARENTHESES_TERMINATOR (291)
    IN (292)
    OUT (293)
    OPEN (294)
    CLOSE (295)
    EQUAL (296)
    NOT_EQUAL (297)
    LEQ (298)
    GEQ (299)
    GREATER_THAN (300)
    NOT (301)
    AND (302)
    OR (303)
    PLUS_OPERATOR (304)
    MINUS_OPERATOR (305)
    MULTI_OPERATOR (306)
    DIVISION_OPERATOR (307)
    MOD_OPERATOR (308)
    POWER_OPERATOR (309)
    CONCAT (310)
    COPY_STRING (311)


Nonterminals, with rules where they appear

    $accept (57)
        on left: 0
    prog (58)
        on left: 1
        on right: 0
    stm <sValue> (59)
        on left: 2 3 4 5 6
        on right: 3 5 6 7 8
    stmlist (60)
        on left: 7 8
        on right: 1 4 8


State 0

    0 $accept: • prog $end

    ID           shift, and go to state 1
    BLOCK_BEGIN  shift, and go to state 2
    WHILE        shift, and go to state 3
    IF           shift, and go to state 4

    prog     go to state 5
    stm      go to state 6
    stmlist  go to state 7


State 1

    2 stm: ID • ASSIGN ID

    ASSIGN  shift, and go to state 8


State 2

    4 stm: BLOCK_BEGIN • stmlist BLOCK_END

    ID           shift, and go to state 1
    BLOCK_BEGIN  shift, and go to state 2
    WHILE        shift, and go to state 3
    IF           shift, and go to state 4

    stm      go to state 6
    stmlist  go to state 9


State 3

    3 stm: WHILE • ID DO stm

    ID  shift, and go to state 10


State 4

    5 stm: IF • ID THEN stm
    6    | IF • ID THEN stm ELSE stm

    ID  shift, and go to state 11


State 5

    0 $accept: prog • $end

    $end  shift, and go to state 12


State 6

    7 stmlist: stm •

    $default  reduce using rule 7 (stmlist)


State 7

    1 prog: stmlist •
    8 stmlist: stmlist • SEMICOLON stm

    SEMICOLON  shift, and go to state 13

    $default  reduce using rule 1 (prog)


State 8

    2 stm: ID ASSIGN • ID

    ID  shift, and go to state 14


State 9

    4 stm: BLOCK_BEGIN stmlist • BLOCK_END
    8 stmlist: stmlist • SEMICOLON stm

    SEMICOLON  shift, and go to state 13
    BLOCK_END  shift, and go to state 15


State 10

    3 stm: WHILE ID • DO stm

    DO  shift, and go to state 16


State 11

    5 stm: IF ID • THEN stm
    6    | IF ID • THEN stm ELSE stm

    THEN  shift, and go to state 17


State 12

    0 $accept: prog $end •

    $default  accept


State 13

    8 stmlist: stmlist SEMICOLON • stm

    ID           shift, and go to state 1
    BLOCK_BEGIN  shift, and go to state 2
    WHILE        shift, and go to state 3
    IF           shift, and go to state 4

    stm  go to state 18


State 14

    2 stm: ID ASSIGN ID •

    $default  reduce using rule 2 (stm)


State 15

    4 stm: BLOCK_BEGIN stmlist BLOCK_END •

    $default  reduce using rule 4 (stm)


State 16

    3 stm: WHILE ID DO • stm

    ID           shift, and go to state 1
    BLOCK_BEGIN  shift, and go to state 2
    WHILE        shift, and go to state 3
    IF           shift, and go to state 4

    stm  go to state 19


State 17

    5 stm: IF ID THEN • stm
    6    | IF ID THEN • stm ELSE stm

    ID           shift, and go to state 1
    BLOCK_BEGIN  shift, and go to state 2
    WHILE        shift, and go to state 3
    IF           shift, and go to state 4

    stm  go to state 20


State 18

    8 stmlist: stmlist SEMICOLON stm •

    $default  reduce using rule 8 (stmlist)


State 19

    3 stm: WHILE ID DO stm •

    $default  reduce using rule 3 (stm)


State 20

    5 stm: IF ID THEN stm •
    6    | IF ID THEN stm • ELSE stm

    ELSE  shift, and go to state 21

    ELSE      [reduce using rule 5 (stm)]
    $default  reduce using rule 5 (stm)


State 21

    6 stm: IF ID THEN stm ELSE • stm

    ID           shift, and go to state 1
    BLOCK_BEGIN  shift, and go to state 2
    WHILE        shift, and go to state 3
    IF           shift, and go to state 4

    stm  go to state 22


State 22

    6 stm: IF ID THEN stm ELSE stm •

    $default  reduce using rule 6 (stm)
